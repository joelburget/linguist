= language simple =

== abstract syntax ==

// first is considered the start
tm ::=
  true()
  false()
  annot(tm; ty)
  ite(tm; tm; tm)
  lam(tm. tm)
  app(tm; tm)

ty ::=
  bool()
  arr(ty; ty)

== concrete syntax ==

- true()          ~ "true";
  false()         ~ "false";
  bool()          ~ "bool";
- annot(tm; ty)   ~ tm ":" ty;
- ite(t1; t2; t3) ~ "if" t1 "then" t2 "else" t3;
- lam(x. t)       ~ "lam" x "." t;
- app(t1; t2)     ~ t1 t2;
- arr(t1; t2)     ~ t1 "->" t2;

== statics ==

// TODO:
// * should we use concrete syntax?
// * how to show var separate from context?
// * how to separate hypotheses?
// * should we make var rule explicit instead of implicit?

----------------------- (bool intro 1)
ctx |- true() => bool()

------------------------ (bool intro 2)
ctx |- false() => bool()

//  ctx[x -> ty]
// -------------- (var)
// ctx |- x => ty

ctx |- tm => ty
--------------- (switch)
ctx |- tm <= ty

      ctx |- tm <= ty
-------------------------- (annot)
ctx |- annot(tm; ty) => ty

ctx |- t1 <= bool()  ctx |- t2 <= ty  ctx |- t3 <= ty
----------------------------------------------------- (bool elim)
           ctx |- ite(t1; t2; t3) <= ty

    ctx, x : ty1 |- tm <= ty2
---------------------------------- (lam intro)
ctx |- lam(x. tm) <= arr(ty1; ty2)

ctx |- tm1 => arr(ty1; ty2)  ctx |- tm2 <= ty1
---------------------------------------------- (lam elim)
        ctx |- app(tm1; tm2) => ty2

== dynamics ==

[[ true()  ]] = true()
[[ false() ]] = false()
[[ annot(tm; ty) ]] = [[ tm ]]
[[ ite(t1; t2; t3) ]] = case([[ t1 ]]; true() -> [[ t2 ]]; false() -> [[ t3 ]])
// [[ lam(x. body) ]] = lam(x.
[[ app(fun; arg) ]] = app([[ fun ]]; [[ arg ]])
